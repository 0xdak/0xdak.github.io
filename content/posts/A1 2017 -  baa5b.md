---
title: "A1 2017 - Injection | Türkçe Çeviri"
date: 2022-04-01T17:24:58+03:00
draft: false
---
Bu içerik, OWASP topluluğunun 2017 senesinde en çok karşılaşılan açıkları bir puana göre sıraladığı ilk 10 listede 1. sırada gelen, OWASP'ın kendi sitesinde
açıkladığı Injection açığının Türkçe çevirisidir.

Orijinal yazıyı okumak isteyenler için link:

https://owasp.org/www-project-top-ten/2017/A1_2017-Injection

Anlamını bilmediğiniz veya benim Türkçe'ye bilerek çevirmediğim terimlerin anlamı için, belki bulmak umuduyla, kendi dilimde açıkladığım terimler sayfasına gidebilirsiniz.



### <em>Tehdit Aktörleri</em> / <em>Saldırı Vektörleri</em>

**Kırılabilirlik: 3**

Hemen hemen herhangi bir veri kaynağı; bir injection vektörü, çevre değişkenleri, parametreler, private ve public web servisleri veya tüm kullanıcı türleri olabilir. Injection açıkları: saldırgan yorumlayıcıya tehditvari bir veri gönderebildiğinde meydana gelir.

### Güvenlik Zayıflığı

**Yaygınlık: 2 | Tespit Edilebilirlik: 3**

Injection açıkları aslında çok yaygındır, özellikle de tarihi geçmiş kodlarda (deprecated). Injection açıkları genellikle SQL, LDAP, XPath, NoSQL sorguları, işletim sistemi komutları, XML-parserlar, SMTP header'ları, expression programlama dilleri ve ORM sorgularında bulunur. 

Kodu incelerken injection açıklarını keşfetmek kolaydır. Scanner'lar ve fuzzer'lar, saldırganların injection açıklarını bulmalarında yardımcı olurlar.

### Etkiler

**Teknik: 3 | İş Hayatına Etkisi ?**

Injection veri kaybına, yolsuzluğa veya illegal partilerin ifşalanmasına, bir partinin suçlanılabilirliğinin kaybına, veya sisteme erişimin reddedilmesine yol açabilir. Injection, bazen host makinanın  devralınmasına neden olabilir.
Injection'ın iş hayatına etkisi, uygulama ve veri ihtiyaçlarına göre değişkenlik gösterebilir.

### Uygulamanız Savunmasız mı?

Bir uygulama şu nedenlerden dolayı saldırıya açıktır:

- Kullanıcı tarafından girilen veri uygulama tarafından onaylanmaz, filtrelenmez veya işleme tabi tutulmazsa
- Dinamik sorgular veya context-aware escaping'siz parametresiz çağrılar direkt olarak yorumlayıcıda kullanılırsa
- Tehditvari veriler, sorguya ek bir şekilde hassas kayıtları elde etme amacıyla, ORM'de arama parametreleri içinde kullanılırsa
- Tehditvari veriler, dinamik sorgular, komutlar veya stored procedure'ler, hem yapısal hem de düşmanca veriler içerek şekilde, SQL veya komut gibi direkt olarak
veya birleştirilerek kullanılırsa

En yaygın injection'lardan bazıları SQL, NoSQL, işletim sistemi komutları, ORM, LDAP ve Expression dili ve OGNL injection'larıdır. Tüm yorumlayıcılarda konsept birebir aynıdır. Kaynak kodun gözden geçirilmesi, bütün parametrelerin, header'ların, URL'lerin, cookie'lerin, JSON, SOAP ve XML veri girdilerinin otomatik teste tabi tutulması, uygulamaların injection zaafiyetleri olup olmadığını saptamak için en iyi yöntemdir.

Kurumlar, ürünün dağıtımıdan önce yeni çıkan injection açıklarını saptamak için,statik kod ve dinamik uygulama test araçlarını CI/CD pipeline'a dahil edebilirler.

### Nasıl Önlenir?

Injection'ı önlemek, veriyi komutlardan ve sorgulardan ayrı tutmayı gerektirir.

- Tercih edilen seçenek, yorumlayıcıyı baştan sona kullanmaktan kaçınan veya parametrize edilmiş bir arayüz sunan veya ORM araçlarını kullanmak için geçiş sunan güvenli bir API kullanmaktır.
    
    **Not**: Parametrize edilse bile, stored procedure'ler, eğer PL/SQL veya T-SQL; sorgu ile veriyi birleştiriyorsa veya tehditvari veriyi EXECUTE IMMEDIATE veya exec() ile kullanıyorsa hala SQL injection'a sebep olabilir.
    
- Server tarafında pozitif veya whitelist girdi kontrolü (input validation) kullanın. Pek çok uygulama [special characters] gerektirdiğinden, bu önlem tam savunma
sağlamayabilir.
- Bahsetmediğimiz diğer dinamik sorgular için, kullandığınız yorumlayıcıya özel escape syntax kullanarak special characters kullanmaktan kaçının.
**Not**: Tablo isimleri, column isimleri ve benzerleri gibi SQL yapıları kullanmaktan mecburen kaçınamayız, bu yüzden kullanıcı tarafından sağlanan yapı isimleri tehlikelidir. Bu yazılımı kodlarken yapılan genel bir hatadır.
- SQL Injection durumunda kayıtların toplu olarak açığa çıkarılmasını önlemek için, sorgularda LIMIT ve diğer SQL kontrollerini kullanın.

### Örnek Saldırı Senaryoları

**Senaryo #1:** Bir uygulama, aşağıdaki zaafiyetli SQL sorgusunu oluştururken güvenilmeyen veriyi birleştiriyor.

```sql
String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";
```

**Senaryo #2:** Benzer bir şekilde, bir uygulamanın framework'lere körü körüne güvenmesi hala zaafiyetli olan sorgulara neden olabilir. (örneğin Hibernate Query Language (HQL)) :

```sql
Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");
```

Her iki durumda da, saldırgan 'id' parametre yerine tarayıcıdan şu değeri girebilir: ‘ or ‘1’=’1. Örneğin;

```sql
http://example.com/app/accountView?id=' or '1'='1
```

Bu değişikler, kayıtların tutulduğu tablodan tüm kayıtları çekmek için, her iki sorgunun da anlamını değiştirir. Daha tehlikeli saldırılar veriyi değiştirmek veya silmek ve hatta 'stored procedure'leri bile çağırmak olabilir.